Ако искаш да е array от pointer-и към обекти от Figure, не трябва да ползваш const Figure &, а ти трябва const Figure **. 
Както Мартин е казал, не е задължително да е array от pointers - затова нарочно е оставено без тип данни, за да може да го направите както искате, 
без да ви ограничавам с някакъв конкретен интерфейс.
Но да, array от pointers би бил добра идея. В твоя код ти просто подаваш референция (не pointer) към една фигура. Референциите като цяло са винаги 
към едно нещо, не към масив от неща (и не можеш да направиш масив от референции, това C++ не го позволява - най-вече защото няма default ctor за 
референция, но нека не задълбаваме в това).
От лекцията за масиви знаем, че можем да си направим int масив (от 10 елемента) така:

int * arr = new int[10];

А ако искаме да си направим масив от някакъв си тип данни, наречен - да речем - T, тогава:

Т * arr = new Т[10];

Ти това, което искаш, е масив, който ти дава достъп до другите фигури. Понеже другите фигури наследяват Figure, за да имаш масив от тях, трябва да 
имаш масив от pointers към тях, за да можеш да ползваш свойствата на полиморфизма (това го знаем от Full C++ OOP лекцията - това явно и ти си се 
сетила, щом си решила да ползваш масив от pointers.
Тоест типа на обектите в твоя масив е Figure* - указател към Figure. И по-конкретно const Figure*, защото няма да променяш подадените фигури, само 
ще ги четеш. Тоест:

const Figure ** figures

или с typedef, както ти си направила:

typedef Figure * FigurePtr; //или typedef const Figure * FigurePtrConst;
FigurePtr * figures = new Figure[32] { new Pawn(...), ... }

(в този пример figures е инициализирано в динамичната памет, в твоя main e в auto паметта - това няма значение за текущия проблем).
Тоест вярно си инициализирала и декларирала масива, но виж параметъра, който ползваш за метода: 

virtual bool moveFigure(const std::string newPosition, Figure & otherFigures) = 0;

Параметърът ти е референция към една фигура, не pointer към масив от FigurePtr. Тоест:

virtual bool moveFigure(const std::string newPosition, FigurePtr * otherFigures) = 0;

Разбира се тук typedef-а ти трябва да е видим за класа, тоест най-вероятно трябва да го напишеш преди класа. И също, понеже имаш pointer, не е лошо 
да подадеш и размера на този масив, към който сочиш, защото иначе няма как да знаеш колко елементи има в това otherFigures (другия вариант е да 
ползваш vector<FigurePtr> otherFigures, така otherFigures ще можеш да му кажеш .size(), или пък да си направиш FigurePtrSmartArray):

typedef Figure * FigurePtr;
class Figure {
...
    virtual std::string* getAvailableMoves(FigurePtr * otherFigures, int numOtherFigures) = 0;
    virtual bool moveFigure(const std::string newPosition, FigurePtr * otherFigures, int numOtherFigures) = 0;
};

Оттам нататък кодът, с който го викаш, е верен и в момента, само трябва да добавиш 32 като параметър за бройката фигури, които са ти в масива.